4.1.1 选择排序
      n个数，遍历n次，每次从i开始，将[i~n]中最小的数与A[i]替换，这样每次遍历时[1~i-1]是有序的
      void selectSort(){
        for(int i=0;i<=n;i++){          //需要带等号
           int k = i;
           for(int j=i;j<=n;j++){      //需要带等号
              if(A[j]<A[k]){
                k = j;
              }
           }
           int temp = A[i];
           A[i] = A[j];
           A[j] = temp;
        }
      }
      
4.1.2 插入排序
     令i从2到n枚举，进行n-1趟操作。假设某一趟，[1~i-1]已经有序，而[i~n]还未有序。
     将A[i]插入到[1~i-1]中的某个位置之中（位置之后元素逐个后移），此时[1~i]有序。
     如:{5,2,4,6,3,1}
        第一趟：当前已有序部分{5}，将{2}插入的{2,5}。。。。
        （插入位置遵循使插入之后仍然保持有序的原则，具体做法一般是从后往前枚举已有序部分确定插入位置）
        
        int A[maxn],n;
        void insertSort(){           
          for(int i=2;i<=n;i++){        //进行n-1次排序
            int temp = A[i],j=i;        //temp临时存放A[i]，j从i开始往前枚举
             while(j>1 && temp < A[j-1]){   //只要temp小于前一个元素A[j-1]
                A[j] = A[j-1];      //把A[j-1]后移一位至A[j]
                j--;
             }
             A[j] = temp;    //插入位置为j，这里的j是不断减1后的j
          }
        }
        
4.1.3 排序题与sort函数的应用
      考试中的排序题大多只要最后结果，而不需要写排序的完整过程，因此推荐直接使用C语言中的库函数qsort或C++中的sort函数进行排序。
    这样可以将更多精力用于题目的逻辑本身。qsort需要对指针的用法有一定的了解，写法上也没有sort简洁，因此更推荐sort。
